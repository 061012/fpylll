.. role:: math(raw)
   :format: html latex
..

.. role:: raw-latex(raw)
   :format: latex
..

FPYLLL
======

::

  >>> from fpylll import IntegerMatrix
  >>> A = IntegerMatrix(9,10)
  >>> A.randomize("intrel", bits=10)

Matrix :math:`A` is a (random) knapsack type matrix. That is of the form  `[ {\bf a} | I_n]`, where `{\bf a}` is a column vector of dimension `n`, and `I_n` the `n`-dimensional identity matrix. Giving

::

  >>> print A
  [ 116 1 0 0 0 0 0 0 0 0 ]
  [ 331 0 1 0 0 0 0 0 0 0 ]
  [ 303 0 0 1 0 0 0 0 0 0 ]
  [ 963 0 0 0 1 0 0 0 0 0 ]
  [ 456 0 0 0 0 1 0 0 0 0 ]
  [ 225 0 0 0 0 0 1 0 0 0 ]
  [ 827 0 0 0 0 0 0 1 0 0 ]
  [ 381 0 0 0 0 0 0 0 1 0 ]
  [  99 0 0 0 0 0 0 0 0 1 ]

    
Also, the following type of matrices are supported,

::

  >>> b = 10
  >>> p = 521 # prime
  >>> A = IntegerMatrix(10,10)
  >>> A.randomize("uniform", bits=b)
  >>> A.randomize("ntrulike", bits=b, q=p)
  >>> A.randomize("ntrulike2", bits=b, q=p)

For a user defined matrix we use the method **from\_matrix**

::

  >>> A = IntegerMatrix.from_matrix([[1,2,3,4],[30,4,4,5],[1,-2,3,4],[0,0,1,0]])


  To compute the Gram-Schimdt form of the matrix `{\bf A}`, we use the **GSO** class

::

  >>> from fpylll import GSO
  >>> M = GSO.Mat(A)
  >>> # to write a vector v as a linear combination of the GS-basis of RowSp(A):
  >>> v = (1,2,5,5)
  >>> _ = M.update_gso()
  >>> print(M.from_canonical(v))
  (1.3333333333333333, -0.013019739605207909, 0.1949374454466105, 1.2521739130434784)
  >>> # the dimension of the GS-matrix :
  >>> print(M.d)
  4

To compute the inner product `{\bf b}_i\cdot {\bf b}^{*}_j` and the coefficient `\mu_{i,j} = {\bf b}_i\cdot {\bf b}^*_j / ||{\bf b}^*_j||^2`

::

  >>> i = 3; j = 2;
  >>> print M.get_r(i,j)
  0.810079798404
  >>> print M.get_mu(i,j)
  0.0584569876831

  To compute the LLL reduced matrix of `{\bf A}`

::

  >>> from fpylll import LLL
  >>> A_lll = LLL.reduction(A)
  >>> print A_lll
  [  0  0 1  0 ]
  [  0 -4 0  0 ]
  [  1  2 0  4 ]
  [ 27 -2 0 -7 ]


For the BKZ reduction of `{\bf A}` with blocksize say 5 (without pruning),

::

  >>> from fpylll import BKZ
  >>> block_size = 5
  >>> A_bkz = BKZ.reduction(A, BKZ.Param(block_size) )
  >>> print A_bkz
  [  0  0 1  0 ]
  [  0 -4 0  0 ]
  [  1  2 0  4 ]
  [ 27 -2 0 -7 ]

  If we want to use pruning we can use the default pruning of fplll.

::

  >>> from fpylll import load_strategies_json, BKZ
  >>> param = BKZ.Param( block_size = block_size, strategies = BKZ.DEFAULT_STRATEGY )
  >>> bkz_reduced = BKZ.reduction(A, param)

To compute the norm of a shortest vector of the lattice generated by the rows of the matrix `{\bf A}` we use the **shortest\_vector** method of the **SVP** class,

::

  >>> from fpylll import SVP
  >>> from numpy import linalg as LA
  >>> import numpy as np
  >>> v_short = SVP.shortest_vector(A)
  >>> LA.norm(np.array([v_short])) # compute its norm
  1.0


Also, the **GaussSieve** algorithm [MV]_ is implemented,

::

  >>> from fpylll import GaussSieve
  >>> A = IntegerMatrix.random(30, "qary", k=15, q=127)  # a q-ary matrix of dim=30
  >>> v = GaussSieve(A, algorithm=2)()

The previous code returns a Shortest vector of the lattice generated by `{\bf A}` using **GaussSieve** algorithm. For the Closest Vector Problem, fplll (and so fpylll) uses enumeration:

::

  >>> from fpylll import CVP
  >>> A = IntegerMatrix.from_matrix([[1,2,3,4],[30,4,4,5],[1,-2,3,4]])
  >>> t = (1, 2, 5, 5)
  >>> v0 = CVP.closest_vector(A, t)
  >>> print v0
  (1, 2, 3, 4)

In fact the following code was executed:

::

  >>> from fpylll.fplll.gso import MatGSO
  >>> from fpylll.fplll.enumeration import Enumeration
  >>> M = MatGSO(A)
  >>> _ = M.update_gso()
  >>> E = Enumeration(M)
  >>> v2, _ = E.enumerate(0, A.nrows, 5, 40, M.from_canonical(t))[0]
  >>> v3 = IntegerMatrix.from_iterable(1, A.nrows, map(lambda x: int(x), v2))
  >>> v1 = v3*A
  >>> print v1
  [ 1 2 3 4 ]

The function Enumeration.enumerate_ requires four mandatory arguments

::

  Enumeration.enumerate(int first,          the first row we consider
                        int last,           the last row we consider
                        max_dist,           the radius of the searching space
                        max_dist_expo,      the exponent of the searching space radius
                        target=None,        None for SVP, the target vector (as a tuple) in the case of SVP
                        subtree=None,
                        pruning=None,
                        dual=False,
                        subtree_reset=False)

.. _Enumeration.enumerate: http://fpylll.readthedocs.io/en/latest/modules.html#fpylll.fplll.enumeration.Enumeration
.. [MV] D. Micciancio, P. Voulgaris,  Faster exponential time algorithms for the shortest vector problem. In: SODA 2010, pp. 1468--1480 (2010).
